require 'toml'

class ScCompiler
  def initialize(scl_file, functions_file, output_file)
    @scl_file = scl_file
    @functions_file = functions_file
    @output_file = output_file
  end

  def compile
    load_functions

    File.open(@output_file, 'w') do |output|
      write_comments(output)
      write_imports(output)
      
      File.open(@scl_file, 'r') do |file|
        file.each_line do |line|
          output.puts translate_command(line) # Write the translated Ruby code to the output file
        end
      end
    end
  end

  private

  def load_functions
    @functions = TOML.load_file(@functions_file)
  end

  def write_comments(output)
    version = @functions['init']['version']
    output.puts "# ----------------------"
    output.puts "# | COMPILED SLASHCODE"
    output.puts "# |-- version: #{version}"
    output.puts "# |"
    output.puts "# | Generated by ScCompiler"
    output.puts "# | Do not modify this file manually"
    output.puts ""
  end

  def write_imports(output)
    enableimports = @functions['init']['enableimports']
    imports = @functions['init']['imports']
  
    return unless enableimports == true && imports && imports.any?
  
    imports.each do |gem_name|
      output.puts "require '#{gem_name}'"
    end
    output.puts "" # Add a newline after imports
  end  

  def translate_command(line)
    parts = line.strip.split(' ')
    command = parts.shift[1..] # Remove the leading '/'

    if @functions['translations'].key?(command)
      translation = @functions['translations'][command].strip # Get the translation string from functions.toml
      args = parts.join(', ') # Join the remaining parts as arguments

      translated_command = translation.gsub(/\$(\d+)/) { args.split(',')[Regexp.last_match(1).to_i - 1] } # Replace placeholders with arguments
    else
      "# Unknown command: #{line.strip}"
    end
  end
end

# usage:
compiler = ScCompiler.new('main.slash', 'slashcode.toml', 'output.rb')
compiler.compile
